/*!

 handlebars v3.0.0

Copyright (C) 2011-2014 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
/* exported Handlebars */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.Handlebars = factory();
  }
}(this, function () {
// handlebars/utils.js
var __module2__ = (function() {
  "use strict";
  var __exports__ = {};
  /*jshint -W004 */
  var escape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
  };

  var badChars = /[&<>"'`]/g;
  var possible = /[&<>"'`]/;

  function escapeChar(chr) {
    return escape[chr];
  }

  function extend(obj /* , ...source */) {
    for (var i = 1; i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }

    return obj;
  }

  __exports__.extend = extend;var toString = Object.prototype.toString;
  __exports__.toString = toString;
  // Sourced from lodash
  // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
  var isFunction = function(value) {
    return typeof value === 'function';
  };
  // fallback for older versions of Chrome and Safari
  /* istanbul ignore next */
  if (isFunction(/x/)) {
    isFunction = function(value) {
      return typeof value === 'function' && toString.call(value) === '[object Function]';
    };
  }
  var isFunction;
  __exports__.isFunction = isFunction;
  /* istanbul ignore next */
  var isArray = Array.isArray || function(value) {
    return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
  };
  __exports__.isArray = isArray;
  // Older IE versions do not directly support indexOf so we must implement our own, sadly.
  function indexOf(array, value) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  }

  __exports__.indexOf = indexOf;
  function escapeExpression(string) {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return "";
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = "" + string;

    if(!possible.test(string)) { return string; }
    return string.replace(badChars, escapeChar);
  }

  __exports__.escapeExpression = escapeExpression;function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }

  __exports__.isEmpty = isEmpty;function blockParams(params, ids) {
    params.path = ids;
    return params;
  }

  __exports__.blockParams = blockParams;function appendContextPath(contextPath, id) {
    return (contextPath ? contextPath + '.' : '') + id;
  }

  __exports__.appendContextPath = appendContextPath;
  return __exports__;
})();

// handlebars/exception.js
var __module3__ = (function() {
  "use strict";
  var __exports__;

  var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

  function Exception(message, node) {
    var loc = node && node.loc,
        line,
        column;
    if (loc) {
      line = loc.start.line;
      column = loc.start.column;

      message += ' - ' + line + ':' + column;
    }

    var tmp = Error.prototype.constructor.call(this, message);

    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }

    if (loc) {
      this.lineNumber = line;
      this.column = column;
    }
  }

  Exception.prototype = new Error();

  __exports__ = Exception;
  return __exports__;
})();

// handlebars/base.js
var __module1__ = (function(__dependency1__, __dependency2__) {
  "use strict";
  var __exports__ = {};
  var Utils = __dependency1__;
  var Exception = __dependency2__;

  var VERSION = "3.0.0";
  __exports__.VERSION = VERSION;var COMPILER_REVISION = 6;
  __exports__.COMPILER_REVISION = COMPILER_REVISION;
  var REVISION_CHANGES = {
    1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
    2: '== 1.0.0-rc.3',
    3: '== 1.0.0-rc.4',
    4: '== 1.x.x',
    5: '== 2.0.0-alpha.x',
    6: '>= 2.0.0-beta.1'
  };
  __exports__.REVISION_CHANGES = REVISION_CHANGES;
  var isArray = Utils.isArray,
      isFunction = Utils.isFunction,
      toString = Utils.toString,
      objectType = '[object Object]';

  function HandlebarsEnvironment(helpers, partials) {
    this.helpers = helpers || {};
    this.partials = partials || {};

    registerDefaultHelpers(this);
  }

  __exports__.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
    constructor: HandlebarsEnvironment,

    logger: logger,
    log: log,

    registerHelper: function(name, fn) {
      if (toString.call(name) === objectType) {
        if (fn) { throw new Exception('Arg not supported with multiple helpers'); }
        Utils.extend(this.helpers, name);
      } else {
        this.helpers[name] = fn;
      }
    },
    unregisterHelper: function(name) {
      delete this.helpers[name];
    },

    registerPartial: function(name, partial) {
      if (toString.call(name) === objectType) {
        Utils.extend(this.partials,  name);
      } else {
        if (typeof partial === 'undefined') {
          throw new Exception('Attempting to register a partial as undefined');
        }
        this.partials[name] = partial;
      }
    },
    unregisterPartial: function(name) {
      delete this.partials[name];
    }
  };

  function registerDefaultHelpers(instance) {
    instance.registerHelper('helperMissing', function(/* [args, ]options */) {
      if(arguments.length === 1) {
        // A missing field in a {{foo}} constuct.
        return undefined;
      } else {
        // Someone is actually trying to call something, blow up.
        throw new Exception("Missing helper: '" + arguments[arguments.length-1].name + "'");
      }
    });

    instance.registerHelper('blockHelperMissing', function(context, options) {
      var inverse = options.inverse,
          fn = options.fn;

      if(context === true) {
        return fn(this);
      } else if(context === false || context == null) {
        return inverse(this);
      } else if (isArray(context)) {
        if(context.length > 0) {
          if (options.ids) {
            options.ids = [options.name];
          }

          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        if (options.data && options.ids) {
          var data = createFrame(options.data);
          data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);
          options = {data: data};
        }

        return fn(context, options);
      }
    });

    instance.registerHelper('each', function(context, options) {
      if (!options) {
        throw new Exception('Must pass iterator to #each');
      }

      var fn = options.fn, inverse = options.inverse;
      var i = 0, ret = "", data;

      var contextPath;
      if (options.data && options.ids) {
        contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
      }

      if (isFunction(context)) { context = context.call(this); }

      if (options.data) {
        data = createFrame(options.data);
      }

      function execIteration(key, i, last) {
        if (data) {
          data.key = key;
          data.index = i;
          data.first = i === 0;
          data.last  = !!last;

          if (contextPath) {
            data.contextPath = contextPath + key;
          }
        }

        ret = ret + fn(context[key], {
          data: data,
          blockParams: Utils.blockParams([context[key], key], [contextPath + key, null])
        });
      }

      if(context && typeof context === 'object') {
        if (isArray(context)) {
          for(var j = context.length; i<j; i++) {
            execIteration(i, i, i === context.length-1);
          }
        } else {
          var priorKey;

          for(var key in context) {
            if(context.hasOwnProperty(key)) {
              // We're running the iterations one step out of sync so we can detect
              // the last iteration without have to scan the object twice and create
              // an itermediate keys array. 
              if (priorKey) {
                execIteration(priorKey, i-1);
              }
              priorKey = key;
              i++;
            }
          }
          if (priorKey) {
            execIteration(priorKey, i-1, true);
          }
        }
      }

      if(i === 0){
        ret = inverse(this);
      }

      return ret;
    });

    instance.registerHelper('if', function(conditional, options) {
      if (isFunction(conditional)) { conditional = conditional.call(this); }

      // Default behavior is to render the positive path if the value is truthy and not empty.
      // The `includeZero` option may be set to treat the condtional as purely not empty based on the
      // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
      if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });

    instance.registerHelper('unless', function(conditional, options) {
      return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
    });

    instance.registerHelper('with', function(context, options) {
      if (isFunction(context)) { context = context.call(this); }

      var fn = options.fn;

      if (!Utils.isEmpty(context)) {
        if (options.data && options.ids) {
          var data = createFrame(options.data);
          data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);
          options = {data:data};
        }

        return fn(context, options);
      } else {
        return options.inverse(this);
      }
    });

    instance.registerHelper('log', function(message, options) {
      var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
      instance.log(level, message);
    });

    instance.registerHelper('lookup', function(obj, field) {
      return obj && obj[field];
    });
  }

  var logger = {
    methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

    // State enum
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,
    level: 1,

    // Can be overridden in the host environment
    log: function(level, message) {
      if (typeof console !== 'undefined' && logger.level <= level) {
        var method = logger.methodMap[level];
        (console[method] || console.log).call(console, message);
      }
    }
  };
  __exports__.logger = logger;
  var log = logger.log;
  __exports__.log = log;
  var createFrame = function(object) {
    var frame = Utils.extend({}, object);
    frame._parent = object;
    return frame;
  };
  __exports__.createFrame = createFrame;
  return __exports__;
})(__module2__, __module3__);

// handlebars/safe-string.js
var __module4__ = (function() {
  "use strict";
  var __exports__;
  // Build out our basic SafeString type
  function SafeString(string) {
    this.string = string;
  }

  SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
    return "" + this.string;
  };

  __exports__ = SafeString;
  return __exports__;
})();

// handlebars/runtime.js
var __module5__ = (function(__dependency1__, __dependency2__, __dependency3__) {
  "use strict";
  var __exports__ = {};
  var Utils = __dependency1__;
  var Exception = __dependency2__;
  var COMPILER_REVISION = __dependency3__.COMPILER_REVISION;
  var REVISION_CHANGES = __dependency3__.REVISION_CHANGES;
  var createFrame = __dependency3__.createFrame;

  function checkRevision(compilerInfo) {
    var compilerRevision = compilerInfo && compilerInfo[0] || 1,
        currentRevision = COMPILER_REVISION;

    if (compilerRevision !== currentRevision) {
      if (compilerRevision < currentRevision) {
        var runtimeVersions = REVISION_CHANGES[currentRevision],
            compilerVersions = REVISION_CHANGES[compilerRevision];
        throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
              "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
      } else {
        // Use the embedded version info since the runtime doesn't know about this revision yet
        throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
              "Please update your runtime to a newer version ("+compilerInfo[1]+").");
      }
    }
  }

  __exports__.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

  function template(templateSpec, env) {
    /* istanbul ignore next */
    if (!env) {
      throw new Exception("No environment passed to template");
    }
    if (!templateSpec || !templateSpec.main) {
      throw new Exception('Unknown template object: ' + typeof templateSpec);
    }

    // Note: Using env.VM references rather than local var references throughout this section to allow
    // for external users to override these as psuedo-supported APIs.
    env.VM.checkRevision(templateSpec.compiler);

    var invokePartialWrapper = function(partial, context, options) {
      if (options.hash) {
        context = Utils.extend({}, context, options.hash);
      }

      partial = env.VM.resolvePartial.call(this, partial, context, options);
      var result = env.VM.invokePartial.call(this, partial, context, options);

      if (result == null && env.compile) {
        options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
        result = options.partials[options.name](context, options);
      }
      if (result != null) {
        if (options.indent) {
          var lines = result.split('\n');
          for (var i = 0, l = lines.length; i < l; i++) {
            if (!lines[i] && i + 1 === l) {
              break;
            }

            lines[i] = options.indent + lines[i];
          }
          result = lines.join('\n');
        }
        return result;
      } else {
        throw new Exception("The partial " + options.name + " could not be compiled when running in runtime-only mode");
      }
    };

    // Just add water
    var container = {
      strict: function(obj, name) {
        if (!(name in obj)) {
          throw new Exception('"' + name + '" not defined in ' + obj);
        }
        return obj[name];
      },
      lookup: function(depths, name) {
        var len = depths.length;
        for (var i = 0; i < len; i++) {
          if (depths[i] && depths[i][name] != null) {
            return depths[i][name];
          }
        }
      },
      lambda: function(current, context) {
        return typeof current === 'function' ? current.call(context) : current;
      },

      escapeExpression: Utils.escapeExpression,
      invokePartial: invokePartialWrapper,

      fn: function(i) {
        return templateSpec[i];
      },

      programs: [],
      program: function(i, data, declaredBlockParams, blockParams, depths) {
        var programWrapper = this.programs[i],
            fn = this.fn(i);
        if (data || depths || blockParams || declaredBlockParams) {
          programWrapper = program(this, i, fn, data, declaredBlockParams, blockParams, depths);
        } else if (!programWrapper) {
          programWrapper = this.programs[i] = program(this, i, fn);
        }
        return programWrapper;
      },

      data: function(data, depth) {
        while (data && depth--) {
          data = data._parent;
        }
        return data;
      },
      merge: function(param, common) {
        var ret = param || common;

        if (param && common && (param !== common)) {
          ret = Utils.extend({}, common, param);
        }

        return ret;
      },

      noop: env.VM.noop,
      compilerInfo: templateSpec.compiler
    };

    var ret = function(context, options) {
      options = options || {};
      var data = options.data;

      ret._setup(options);
      if (!options.partial && templateSpec.useData) {
        data = initData(context, data);
      }
      var depths,
          blockParams = templateSpec.useBlockParams ? [] : undefined;
      if (templateSpec.useDepths) {
        depths = options.depths ? [context].concat(options.depths) : [context];
      }

      return templateSpec.main.call(container, context, container.helpers, container.partials, data, blockParams, depths);
    };
    ret.isTop = true;

    ret._setup = function(options) {
      if (!options.partial) {
        container.helpers = container.merge(options.helpers, env.helpers);

        if (templateSpec.usePartial) {
          container.partials = container.merge(options.partials, env.partials);
        }
      } else {
        container.helpers = options.helpers;
        container.partials = options.partials;
      }
    };

    ret._child = function(i, data, blockParams, depths) {
      if (templateSpec.useBlockParams && !blockParams) {
        throw new Exception('must pass block params');
      }
      if (templateSpec.useDepths && !depths) {
        throw new Exception('must pass parent depths');
      }

      return program(container, i, templateSpec[i], data, 0, blockParams, depths);
    };
    return ret;
  }

  __exports__.template = template;function program(container, i, fn, data, declaredBlockParams, blockParams, depths) {
    var prog = function(context, options) {
      options = options || {};

      return fn.call(container,
          context,
          container.helpers, container.partials,
          options.data || data,
          blockParams && [options.blockParams].concat(blockParams),
          depths && [context].concat(depths));
    };
    prog.program = i;
    prog.depth = depths ? depths.length : 0;
    prog.blockParams = declaredBlockParams || 0;
    return prog;
  }

  __exports__.program = program;function resolvePartial(partial, context, options) {
    if (!partial) {
      partial = options.partials[options.name];
    } else if (!partial.call && !options.name) {
      // This is a dynamic partial that returned a string
      options.name = partial;
      partial = options.partials[partial];
    }
    return partial;
  }

  __exports__.resolvePartial = resolvePartial;function invokePartial(partial, context, options) {
    options.partial = true;

    if(partial === undefined) {
      throw new Exception("The partial " + options.name + " could not be found");
    } else if(partial instanceof Function) {
      return partial(context, options);
    }
  }

  __exports__.invokePartial = invokePartial;function noop() { return ""; }

  __exports__.noop = noop;function initData(context, data) {
    if (!data || !('root' in data)) {
      data = data ? createFrame(data) : {};
      data.root = context;
    }
    return data;
  }
  return __exports__;
})(__module2__, __module3__, __module1__);

// handlebars.runtime.js
var __module0__ = (function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
  "use strict";
  var __exports__;
  /*globals Handlebars: true */
  var base = __dependency1__;

  // Each of these augment the Handlebars object. No need to setup here.
  // (This is done to easily share code between commonjs and browse envs)
  var SafeString = __dependency2__;
  var Exception = __dependency3__;
  var Utils = __dependency4__;
  var runtime = __dependency5__;

  // For compatibility and usage outside of module systems, make the Handlebars object a namespace
  var create = function() {
    var hb = new base.HandlebarsEnvironment();

    Utils.extend(hb, base);
    hb.SafeString = SafeString;
    hb.Exception = Exception;
    hb.Utils = Utils;
    hb.escapeExpression = Utils.escapeExpression;

    hb.VM = runtime;
    hb.template = function(spec) {
      return runtime.template(spec, hb);
    };

    return hb;
  };

  var Handlebars = create();
  Handlebars.create = create;

  /*jshint -W040 */
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function() {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
  };

  Handlebars['default'] = Handlebars;

  __exports__ = Handlebars;
  return __exports__;
})(__module1__, __module4__, __module3__, __module2__, __module5__);

  return __module0__;
}));

/*
 Copyright (c) 2012 Alan Lindsay - version 2.7.6

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
(Kernel = function() {

  var core, hubs = { }, modules = {}, registered = {},
      listeners = {},
      defaultHub = 'main';

  // Forces a string to an array
  function strToArray(str) {

    if (isString(str)) str = [str];

    return str;
  }

  function isString(str) {

    return Object.prototype.toString.call(str) == '[object String]';
  }

  // Should only used for Kernel, modules and hubs
  function decorateMethods(obj, proto) {

    var key, method;

    if (!obj) return;

    for (key in obj) {

      if (obj.hasOwnProperty(key) || proto) {

        if (key === 'decorateMethod' || key === 'decorateMethods') return;

        if (!obj._decoratedMethods) obj._decoratedMethods = {};

        if (!obj._decoratedMethods[key]) {

          method = obj[key];

          if (typeof method === 'function') {

            // Reassign method
            obj[key] = core.decorateMethod(obj, key, method);

            // Track decorated methods for later decoration calls
            obj._decoratedMethods[key] = true;
          }
        }
      }
    }
  }

  function setDefaultHub(name) {

    defaultHub = name;
  }

  function mergeParents(module) {

    var parents, parent, merged = {};

    if (module.extend) {

      // Cast to array
      parents = strToArray(module.extend);

      for (i=0; i<parents.length; i+=1) {

        // Create module instance
        parent = parents[i];
        parent = modules[parent];

        if (parent) Kernel.extend(merged, parent, true);
      }
    }

    return Kernel.extend(merged, module, true);

  }

  function defineModule(name, Definition) {

    // Expand defintion (include parents)
    modules[name] = mergeParents(Definition);

  }

  function defineHub(name, Definition) {

    // Create instance
    var broadcastCount = {event: 0}, callbackCount = {event: 0},
        totalElapseTime = {event: 0}, h = Definition;

    h._internals = { type: 'hub' };
    h.id = name;

    // Add built-in methods - these override any definition methods
    h.broadcast = function(type, data, callback, id) {

      var i, l, e = listeners.event, size, eventData,
          start, diff, elapseTime = 0, listenerData = [], mutate;

      // Hook in for debugging or mutation purposes
      if (h.beforeBroadcast) {
        mutate = h.beforeBroadcast(type, data, id);

        if (mutate.type) type = mutate.type;
        if (mutate.data) data = mutate.data;
      }

      // Get the listeners
      l = listeners[type];

      // Increment the broadcastCount
      broadcastCount[type] = broadcastCount[type] || 0;
      broadcastCount[type] += 1;
      broadcastCount.event += 1;
      callbackCount[type] = callbackCount[type] || 0;
      totalElapseTime[type] = totalElapseTime[type] || 0;

      // Cycle through the listeners and call the callbacks
      if (l) {

        for (i=0,size=l.length; i<size; i+=1) {

          // Measure how long it takes to complete
          start = (new Date()).getTime();

          listeners[type][i].callback(data, id);

          diff = (new Date()).getTime() - start;
          elapseTime += diff;
          totalElapseTime[type] += diff;
          totalElapseTime.event += diff;

          // Increment the listener count
          callbackCount[type] += 1;
          callbackCount.event += 1;

          listenerData.push({
            id: listeners[type][i].id,
            elapseTime: diff,
            callback: listeners[type][i].callback
          });
        }
      }

      // Now cycle through the 'event' event listeners
      if (e) {

        eventData = {
          type: type,
          data: data,
          time: new Date(),
          listeners: listenerData,
          broadcastCount: broadcastCount[type],
          callbackCount: callbackCount[type],
          elapseTime: elapseTime,
          totalElapseTime: totalElapseTime[type],
          all: {
            broadcastCount: broadcastCount.event,
            callbackCount: callbackCount.event,
            totalElapseTime: totalElapseTime.event
          }
        };

        for (i=0,size=e.length; i<size; i+=1) {
          listeners.event[i].callback(eventData);
        }
      }

      // Handle callback if provided
      if (callback) callback();
    };

    // Provide an authorization method if not present.
    // Everything is authorized by default.
    h.authorized = h.authorized || function(type, moduleId) { return true; };

    h.listen = function(type, callback, moduleId) {

      // If not a module then store in hub id
      moduleId = moduleId || 'hub-'+h.id;

      var i, size, t;

      // Cast to array if string
      type = strToArray(type);

      for (i=0,size=type.length; i<size; i+=1) {

        t = type[i];

        // Only setup callbacks if authorized
        if (h.authorized(type, moduleId)) {
          // Force array
          listeners[t] = listeners[t] || [];
          listeners[t].push({callback: callback, id: moduleId});
        }
      }
    };

    h.getStats = function() {
      return {
        broadcastCount: broadcastCount,
        callbackCount: callbackCount,
        totalElapseTime: totalElapseTime
      };
    };

    h.share = function(obj) {

      Kernel.extend(h, obj);
    };

    // Decorate during instatiation
    decorateMethods(h);

    // Store hub in hubs array
    hubs[name] = h;
  }

  // This checks for DOM nodes and 3rd party lib objects that should not be deep copied
  function skipDeepCopy(obj) {

    try {

      // Put other libs here if desired
      if (obj instanceof RegExp) return true;
      if (obj instanceof Node) return true;
      if (obj instanceof jQuery) return true;

    }
    catch (e) {
      // In order to run in non-DOM environments like node.js
    }

    return false;
  }

  function extend(obj1, obj2, deep, proto, mergeArrays) {

    var key, i, l;

    // Filter out null values
    if (obj2 === null) return obj1;

    // Reset arrays and objects if needed
    if (typeof obj1 !== "object" || !obj1) obj1 = (obj2 instanceof Array) ? [] : {};

    // Force deep extend & decoration for hubs and modules
    if (obj1._internals && (obj1._internals.type === 'module' || obj1._internals.type === 'hub') ) {

      deep = true;
      decorateMethods(obj1, true);
    }

    // Empty arrays unless otherwise specified
    if (obj1 instanceof Array && obj2 instanceof Array && (!mergeArrays)) {

      // empty the target array so as not to leave behind extra values
      obj1 = [];
    }

    // Loop through the keys
    for (key in obj2) {

      if (obj2.hasOwnProperty(key) || proto) {

        // Skip duplicates, internals and recursive copies
        if (obj1[key] === obj2[key]) continue;
        if (key === '_internals') continue;
        if (key === '_parent') continue;
        if (key === '_children') continue;
        if (obj1 === obj2[key]) continue;

        // Skip recursive hub references
        if (key === 'hub' && obj2[key]._internals && obj2[key]._internals.type === 'hub') continue;

        // Handle special objects (RegExp, Node, jQuery, etc.)
        if (skipDeepCopy(obj2[key])) {
          obj1[key] = obj2[key];
          continue;
        }

        // Handle recursion
        if (deep && typeof obj2[key] === 'object') {

          obj1[key] = Kernel.extend(obj1[key], obj2[key], deep, proto, mergeArrays);
        }
        else {

          if (obj1._internals && obj1._internals.type === 'Kernel') {

            // Disallow overwriting base objects
            switch (key) {
              case 'extend':
              case 'decorateMethods':
              case 'module':
              case 'register':
              case 'hub':
              case 'start':
              case 'stop':
              case 'version':
              case '_internals':
                throw "You can't extend '"+key+"', it's part of Kernel's base functionality.";

              default:
              // Assignment below
            }
          }
          else if (obj1._internals && obj1._internals.type === 'module') {

            // Disallow overridding module ids
            if (key === 'id') throw "You can't overwrite a module instance id. ["+obj1.id+"]";
          }

          // Merge arrays, don't override indexes blindly
          if (obj1 instanceof Array && obj2 instanceof Array && mergeArrays) {

            // Filter out duplicates
            for (i=0, l=obj1.length; i<l; i+=1) {
              if (obj1[i] === obj2[key]) continue;
            }

            // Add non-duplicates
            obj1.push(obj2[key]);
          }
          else {
            // Make the assignment
            obj1[key] = obj2[key];
          }
        }
      }
    }

    return obj1;
  }

  // This will create a module instance - but it won't call its init method.
  function registerModule(id, type, hub, config, core) {

    var hub = hub || defaultHub, instance;

    registered[id] = {
      hub: hubs[hub],
      started: false,
      Definition: modules[type]
    };

    // Create a module instance
    try {
      instance = Kernel.extend(mergeParents(registered[id].Definition), registered[id].Definition, true);
    }
    catch (e) {
      throw "Couldn't register module: ["+id+"] - missing or broken Definition: "+e.message;
    }

    // Merge config into instance
    if (config) Kernel.extend(instance, config, true);

    // Add built-ins
    instance._internals = { type: 'module', moduleType: type };
    instance.kill = instance.kill || function() {};
    instance.id = id;

    // Setup access to the hub
    var H = function() {};
    H.prototype = registered[id].hub;

    instance.hub = new H;
    instance.hub.broadcast = function(type, data, callback) {
      registered[id].hub.broadcast(type, data, callback, id);
    };
    instance.hub.listen = function(type, callback) {
      registered[id].hub.listen(type, callback, id);
    };
    instance.hub._internals = Kernel.extend(registered[id].hub._internals, { moduleId: id, moduleType: type });

    // Decorate methods
    decorateMethods(instance, true);

    // Save the instance
    registered[id].instance = instance;

    // execute callbacks if provided
    if (core.onRegister) core.onRegister(registered[id].instance);
    if (registered[id].instance.onRegister) registered[id].instance.onRegister();
  }

  // Automatically regsiters modules assigning ids based on the provided function
  function autoRegisterModules(fn) {
    
    var type;
    
    fn = fn || function(type) {
      return type.toString().replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
    }
    
    for (type in core._internals.modules) {
      core.register(fn(type), type);
    }
    
  }

  function unregisterModule(id) {

    // Stop the module if started
    if (registered[id].instance.started) Kernel.stop(id);

    delete registered[id];
  }

  function startModule(id, config, core) {

    if (core.module.isStarted(id)) return;

    // Merge config into instance
    if (config) extend(registered[id].instance, config, true);

    // Set module as started
    registered[id].started = true;

    // Initialize the module
    return core.onStart(registered[id].instance);
  }

  core = {
    extend: extend,
    decorateMethods: decorateMethods,
    module: {
      define: defineModule,
      get: function(id) {

        if (!registered[id]) throw "Couldn't get instance for: "+id+", is it registered?";

        return registered[id].instance;
      },
      getDefinition: function(type) {
        return modules[type];
      },
      isStarted: function(id) {
        return registered[id].started;
      }
    },
    hub: {
      define: defineHub,
      get: function(id) {
        return hubs[id];
      }
    },
    register: function(id, type, hub, config) {

      var i;

      // Check to see if an array is being used
      if (isString(id)) {

        registerModule(id, type, hub, config, this);
      }
      else {
        // Register all the modules
        for (i=0; i<id.length; i+=1) {

          registerModule(id[i].id, id[i].type, id[i].hub, id[i].config, this);
        }
      }
    },
    unregister: unregisterModule,
    autoRegisterModules: autoRegisterModules,
    start: function(id, config) {

      var i;

      // Check to see if an array is being used
      if (isString(id)) {

        return startModule(id, config, this);
      }
      else {
        // Start all the modules
        for (i=0; i<id.length; i+=1) {

          startModule(id[i].id, id[i].config, this);
        }
      }
    },
    startAll: function() {

      var key;

      for (key in registered) {

        startModule(key, null, this);
      }
    },
    onStart: function(instance, callback) {
      instance.init();
      if (callback) callback();
    },
    decorateMethod: function(instance, name, method) {

      return function() {

        // Bind instance methods
        return method.apply(instance, arguments);
      };
    },
    stop: function(id) {

      var key, i, size, listener;

      // Call the module kill method first
      this.onStop(registered[id].instance);

      // Wipe out any listeners
      for (key in listeners) {

        // Cycle through each type
        for (i=listeners[key].length-1; i>=0; i-=1) {
          listener = listeners[key][i];
          if (listener.id === id) listeners[key].splice(i, 1);
        }
      }

      // Flag the module
      registered[id].started = false;
    },
    onStop: function(instance) {
      instance.kill();
    },
    version: '2.7.6',
    _internals: {
      PRIVATE: 'FOR DEBUGGING ONLY',
      type: 'Kernel',
      hubs: hubs,
      modules: modules,
      registered: registered,
      listeners: listeners
    }
  };

  return core;

}());

// Define main hub
Kernel.hub.define('main', {});

this["Handlebars"] = this["Handlebars"] || {};

this["Handlebars"]["greeter"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<h1>Hello "
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{},"data":data}) : helper)))
    + "</h1>";
},"useData":true});

this["Handlebars"]["toilets-list-show"] = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper, alias1=helpers.helperMissing, alias2="function", alias3=this.escapeExpression;

  return "    "
    + alias3(((helper = (helper = helpers.Id || (depth0 != null ? depth0.Id : depth0)) != null ? helper : alias1),(typeof helper === alias2 ? helper.call(depth0,{"name":"Id","hash":{},"data":data}) : helper)))
    + ": "
    + alias3(((helper = (helper = helpers.Name || (depth0 != null ? depth0.Name : depth0)) != null ? helper : alias1),(typeof helper === alias2 ? helper.call(depth0,{"name":"Name","hash":{},"data":data}) : helper)))
    + " : "
    + alias3(((helper = (helper = helpers.Address || (depth0 != null ? depth0.Address : depth0)) != null ? helper : alias1),(typeof helper === alias2 ? helper.call(depth0,{"name":"Address","hash":{},"data":data}) : helper)))
    + "\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.data : depth0),{"name":"each","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop,"data":data})) != null ? stack1 : "");
},"useData":true});
Kernel.extend(Kernel, {
    onRegister: function (instance) {
        //check if module exists
        var availableModules = this._internals.modules;
        var loadingModule = instance._internals.moduleType;
        if (!(loadingModule in availableModules)) {
            //throw a useful error if the module name does not match any loaded modules
            var keys = [];
            for (var key in availableModules) {
                keys.push(key);
            }
            throw new Error("Module " + loadingModule + " not found. Available options are " + JSON.stringify(keys));
        }
    },

    onStart: function (instance) {
        instance.init();
    },

    onStop: function (instance) {
        instance.kill();
    }
});
Kernel.hub.define('toilets', {
    init: function () {
        var self = this;
        console.log('toilet hub started');
        self.listen('fetch-toilets-list', function () {
            console.log('fetching toilets...')
            $.ajax({
                url: "toilets",
                contentType: 'application/json',
                success: function (data) {
                    hub.broadcast('fetched-toilets-list', data);
                },
                error: function () {
                    hub.broadcast('error', 'error fetching toilet data');
                }
            });
        });
    }
});

var hub = Kernel.hub.get('toilets');
hub.init();



Kernel.module.define('greeter', {
    renderTo: "#greeter",

    init: function () {
        var self = this;
        console.log(self);
        self.template = Handlebars[self._internals.moduleType];
        var data = {};
        data.name = "James Kelly"
        self.render(data);
    },

    render: function (data) {
        var self = this;
        console.log(data);
        console.log(self.template(data));
        $(self.renderTo).html(self.template(data));
    }
});

Kernel.module.define('toilets-list-show', {
    renderTo: "#toilets-list-show",

    init: function () {
        var self = this;
        var hub = self.hub;
        self.template = Handlebars[self._internals.moduleType];
        hub.broadcast('fetch-toilets-list');

        hub.listen('fetched-toilets-list', function (data) {
            self.render(data)
        });
    },

    render: function (data) {
        var self = this;
        $(self.renderTo).html(self.template(data));
    }
});

Kernel.register('greeter', 'greeter');
Kernel.register('toilets-list-show', 'toilets-list-show');

$('document').ready(function () {
    Kernel.startAll();
});